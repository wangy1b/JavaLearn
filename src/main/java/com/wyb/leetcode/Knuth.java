package com.wyb.leetcode;

import java.util.Arrays;
import java.util.Random;


/*
设计一个公平的洗牌算法:
问题来了，对于一个洗牌算法来说，什么叫“公平”？这其实是这个问题的实质，我们必须定义清楚：什么叫公平。
一旦你开始思考这个问题，才触及到了这个问题的核心。在我看来，不管你能不能最终给出正确的算法，
如果你的思路是在思考对于洗牌算法来说，什么是“公平”，我都觉得很优秀。

1.暴力法
什么叫公平呢？一旦你开始思考这个问题，其实答案不难想到。
洗牌的结果是所有元素的一个排列。
一副牌如果有 n 个元素，最终排列的可能性一共有 n! 个。公平的洗牌算法，应该能等概率地给出这 n! 个结果中的任意一个。

如思考到这一点，我们就能设计出一个简单的暴力算法了：对于 n 个元素，生成所有的 n! 个排列，然后，随机抽一个。
这个算法绝对是公平的。但问题是，复杂度太高。复杂度是多少呢？O(n!)。因为，n 个元素一共有 n! 种排列，我们求出所有 n! 种排列，至少需要 n! 的时间。
所以，这个算法确实是公平的，但是，时间不可容忍。

2.转换
我们再换一个角度思考“公平”这个话题。
其实，我们也可以认为，公平是指，对于生成的排列，每一个元素都能等概率地出现在每一个位置。
或者反过来，每一个位置都能等概率地放置每个元素。

这个定义和上面的最终洗牌结果，可以等概率地给出这 n! 个排列中的任意一个，是等价的。
这个等价性，可以证明出来。并不难。如果正在学习概率论的同学，还比较习惯概率论处理问题的思想，应该能很快搞定。
for(int i = n-1; i >= 0 ; i--){
    swap(arr[i],arr[rand() % (i+1)]);
}
遍历数组，i 从后向前，每次随机一个 [0...i] 之间的下标，然后将 arr[i] 和这个随机的下标元素，也就是 arr[rand() % (i + 1)] 交换位置。
注意，由于每次是随机一个 [0...i] 之间的下标，所以，我们的计算方式是 rand() % (i + 1)，要对 i + 1 取余，保证随机的索引在 [0...i] 之间。

 */
public class Knuth {


    // 算法，可以保证上面我所说的，对于生成的排列，每一个元素都能等概率的出现在每一个位置。
    // 或者反过来，每一个位置都能等概率的放置每个元素。
    public static void randomize(int arr[], int n) {
        Random r = new Random();
        for (int i = n - 1; i > 0; i--) {
            int j = r.nextInt(i + 1); // 选择一个 [0,i] 的随机数
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        System.out.println(Arrays.toString(arr));
    }

    public static void main(String[] args) {
        // 纸牌编号
        int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8,
                9, 10, 11, 12, 13, 14, 15,
                16, 17, 18, 19, 20, 21, 22,
                23, 24, 25, 26, 27, 28, 29,
                30, 31, 32, 33, 34, 35, 36,
                37, 38, 39, 40, 41, 42, 43,
                44, 45, 46, 47, 48, 49, 50, 51};


        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8};
        int n = arr.length;
        // randomize (arr, n);
        randomize(a, 52);
    }
}
